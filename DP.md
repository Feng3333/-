# 动态规划（Dynamic Programming，DP）

## 背包问题

### 01背包问题
01背包问题是指：给定物品的价值和体积 (对应了 [ 给定价值和成本 ] ) ，在规定的容量下 (对应了 [ 限定决策规则 ] ) 如何使得所选物品的总价值达到最大;  

#### 题目描述:
有 N 件物品和一个容量是 V 的背包。每件物品有且只有一件。  
第 i 件物品的体积是 v[i] ，价值是 w[i] 。  
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。  

事例1:
```
输入：N = 3, V = 4, v = [4,2,3], w = [4,2,3];
输出：4
解释：只选择第一件物品，可使价值达到最大
```

事例2:
```
输入：N = 3, V = 5, v = [4,2,3], w = [4,2,3];
输出：5
解释：不选第一件物品，选择第二和第三件物品，可使价值达到最大
```

#### dp[N][C+1] 解法
如果要设计一个DFS函数对所有方案进行枚举的话，大概函数签名为：
```
int dfs (vector<int> & v, vector<int> & w, int i, int c)
```
其中 v 和 w 对应了输入的 [ 物品体积 ] 和 [ 物品价值 ] , 属于不变参数，无需考虑  
而 i 和 c 分别代表 [ 当前枚举到哪件物品 ] 和 [ 背包的剩余容量 ] 。  
返回值则是问题的答案：最大价值  

那么根据变化参数和返回值，可以抽象出相关的 dp 数组：  
一个二维数组，其中一维表示 [ 当前枚举到哪一件物品 ] , 另外一维表示 [ 现在的剩余容量]， 数组装的是最大价值。  
根据dp数组可以得出状态定义：  
考虑前 i 件物品，使用容量不超过 C 的条件下的背包最大价值;  
当有了状态定义之后，我们再根据 [ 最后一步 ] 来推导出 [ 状态转移方程 ]。

不失一般性的，只需要考虑第 i 件物品如何选择即可，对于第 i 件物品，可以有 [选] 和 [不选] 两种决策  

结合 [ 状态定义 ] , [不选] 的 [ 最大价值] 很好确定：    
[不选] 其实就是 dp[i-1][c] ,等效于只考虑前 i-1 件物品，当前容量为 c 的情况下得最大价值；  
同理，如果选择了第i件物品，代表消耗了 v[i] 的背包容量,获取了 w[i] 的价值，那么留给前 i-1 件物品的背包容量只剩 c-v[i]。最大价值为dp[i-1][c-v[i]] + w[i];  
当然，选择第 i 件物品还有个必要的前提，就是 [物品的体积] <= [当前背包的剩余容量];

在「选」和「不选」之间取最大值，就是我们「考虑前  件物品，使用容量不超过  」的条件下的「背包最大价值」。  
即可得「状态转移方程」为：
```c++
dp[i][c] = max (dp[i-1][c] , dp[i-1][c-v[i]] + w[i]);
```

代码：  
```c++
class Solution {
public:
    int maxValue (int N, int C, vector<int> & v, vector<int> & w) {
    
        vector<vector<int>> dp(N,vector<int>(C+1));
        
        //先处理考虑[第一件物品]的情况
        for (int i=0; i<=C; i++) {
            dp[0][i] = i >= v[0] ? w[0] : 0;
        }
        
        //在处理考虑[其他物品]的情况
        for (int i=1; i<N; i++) {
            for (int j=0; j<C+1; j++) {
                //不选第i件物品
                int n = dp[i-1][j];
                // 选择第i件物品，前提是[剩余容量] 大于[背包的剩余容积]
                int y = j >= v[i] ? dp[i-1][j-v[i]] + w[i] : 0;
                dp[i][j] = max(n,y);
            }
        }
        
        return dp[N-1][C];
    }
};
```
时间复杂度：共有 N\*C 个状态需要转移，复杂度为O(N\*C)  
空间复杂度：O(N*C)  

#### d[2][C+1]解法

根据[转移方程],计算第 i 行格子只需要 i - 1 行中的某些值;  
也就是计算 [某一行] 的时候只需要依赖 [前一行];  
因此可以使用一个只有两行的数组来存储中间结果，根据当前计算的行号是奇数还是偶数来交替使用第 0 行和第 1 行；  
这样的空间优化方法称为[滚动数组];  
只需要将代表行的的维度修改成2，并将所有使用行维度的地方从 i 改成 i%2 或者 i&1 即可（更建议使用 i&1 ， & 运算在不同 CPU 架构的机器上要比 % 运算稳定）

代码如下:
```c++
class Solution {
public:
    int maxValue (int N, int C, vector<int> & v, vector<int> & w) {
        vector<vector<int>> dp(2,vector<int>(C+1));
        
         //先处理考虑[第一件物品]的情况
        for (int i=0; i<=C; i++) {
            dp[0][i] = i >= v[0] ? w[0] : 0;
        }
        
         //在处理考虑[其他物品]的情况
        for (int i=1; i<N; i++) {
            for (int j=0; j<C+1; j++) {
                //不选第i件物品
                int n = dp[(i-1)&1][j];
                // 选择第i件物品，前提是[剩余容量] 大于[背包的剩余容积]
                int y = j >= v[i] ? dp[(i-1)&1][j-v[i]] + w[i] : 0;
                dp[i&1][j] = max(n,y);
            }
        }
        
        return dp[(N-1)&1][C]
    }
};
```
时间复杂度：共有 N\*C 个状态需要转移，复杂度为O(N\*C)   
空间复杂度：O(C)  

