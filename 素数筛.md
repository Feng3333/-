# 素数筛
## 目录
 - [1.0 基本概念](#1-基本概念)
 - [2.0 判断质数的朴素算法](#2-判断质数的朴素算法)
 - [3.0 埃氏筛](#3-埃氏筛)
 - [4.0 欧拉筛(线性筛)](#4-欧拉筛线性筛)
## 1. 基本概念
- 素数: 也叫质数, 是指在大于1的自然数中, 除了1和它本身外不再有其他因数的自然数。比如:2、3、5、7、11...  
- 合数: 素数的反义词, 是指在大于1的整数中, 除了能被1和自身整除外, 还能被其他数(0除外)整除的数; 与之相对的是质数; 4是最小的合数.  
- 1既不属于质数也不属于合数.  
- 因数: 如果整数 a 除以整数 b(b != 0) 的商恰好是整数且没有余数，则称 b 是 a 的因数.  

## 2. 判断质数的朴素算法
基本逻辑代码:
```c++
bool isPrimeNum(int num)
{
  if (num <= 1) return false;
  for (int i = 2; i*i <= num; ++i) {
      if (num % i == 0) {
          return false;
      }
  }
  return true;
}
```
时间复杂度: O(√n) 其中 n 为需要判断的数字
假设num是一个合数，那么会有num = n1 * n2, 其中 n1,n2 > 1; 所以其中一个数一定不超过√num,如果全部超过√num, 则 n1 * n2 必然大于 num,因此只需遍历到 √num;

## 3. 埃氏筛
对于一个质数而言, 它的倍数一定是合数, 因此可以定义一个数组, 把所有的质数的倍数都标记一遍, 直到达到边界 n 停止, 这样数组中为被标记的元素则是素数;  
另外在通过较小质数筛掉合数的过程中, 只需要遍历到不超过 √n 的质数即可完成筛选(举个例子: 假如筛100内的质数，则只需要不超过10的质数：2、3、5、7，即可对100以内的所有质数进行全部筛选);  

具体逻辑代码:  
```c++
#include <iostream>
#include <vector>

const int len = 1e7 + 10;

std::vector<bool> nums(len); //标记数组，true代表该数是合数，false代表该数是质数

void isPrimeNum(int num) 
{
    //对0 、1进行特殊处理
    nums[0] = true;
    nums[1] = true;
    for (int i = 2; i * i <= num; ++i) {
        //先判断 nums[i] 是否被标记
        if (!nums[i]) { 
            for (int j = i + i; j <= num; j += i) {
                nums[j] = true; //将其标记为合数
            }
        }
    }
}

int main() {
    isPrimeNum(100);
    for (int i = 2; i <= 100; ++i) {
        if (!nums[i]) {
            std::cout << i << " ";
        }
    }
    return 0;
}
```
时间复杂度: O(n\*log(logn))

## 4. 欧拉筛(线性筛)
#### 线性筛的基本原理
在埃氏筛中，会有一部分合数会被不同的质数重复标记一次, 比如6、10等等、因此增加了运算次数, 是否有方法可以避免重复操作，使每个合数只被标记一次?  
通过观察发现: 6分解因数(除1和本身)为2和3, 10分解因数为2和5, 再结合前面用到的推论:  
```
一个合数一定存在一个小于等于 √num 的质数 p, 使得num = p * q 成立
```
因此可以推出: 对于一个合数, 其只被最小的质因数筛,而与之对应的就是非本身的最大因数, 比如对于28这个数字,非本身最大因数是14,与之对应的最小质因数则为2，  
这样就可以做到筛选时不重复且不漏掉合数，总结出公式为:  
```
非自身最大因数 × 最小质因数 = 该合数
```
对于这个结论也可以运用唯一分解定理: 任何一个大于1的整数n都可以分解成若干素因数的连乘积, 如果不计各个素因数的顺序，那么这种分解是唯一的;  
最终目的: 找到一个数的最小质因子时就停止后续标记;

#### 具体逻辑代码
```c++
#include <iostream>
#include <vector>

const int len = 1e7 + 10;

std::vector<bool> nums(len); //标记数组，true代表该数是合数，false代表该数是质数
std::vector<int> primes(len); //保存质数
int pos; //记录质数数组中当前保存到的位置

void isPrimeNum(int num) 
{
    //对0 、1进行特殊处理
    nums[0] = true;
    nums[1] = true;
    for (int i = 2; i <= num; ++i) {
        //先判断 nums[i] 是否被标记
        if (!nums[i]) { 
            primes[pos++] = i;
        }
        for (int j = 0; primes[j] <= num / i; ++j) {
            // 素数的倍数一定是合数,且primes[j]一定是primes[j] * i的最小质因数
            nums[primes[j] * i] = true; 
            if(i % primes[j] == 0) {
                break;
            }
        }
    }
}

int main() {
    isPrimeNum(100);
    for (int i = 2; i <= 100; ++i) {
        if (!nums[i]) {
            std::cout << i << " ";
        }
    }
    return 0;
}
```
时间复杂度: O(n) 具体证明可百度



