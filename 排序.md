## 1.冒泡排序

最简单的一种排序算法。假设长度为n的数组arr，要按照从小到大排序。则冒泡排序的具体过程可以描述为：
首先从数组的第一个元素开始到数组最后一个元素为止，对数组中相邻的两个元素进行比较，如果位于数组左端的元素大于数组右端的元素，则交换这两个元素在数组中的位置。这样操作后数组最右端的元素即为该数组中所有元素的最大值。接着对该数组除最右端的n-1个元素进行同样的操作，再接着对剩下的n-2个元素做同样的操作，直到整个数组有序排列。算法的时间复杂度为O(n^2)。

代码：

```c++
/* 冒泡排序 */
void BubbleSort ( vector<int> arr, int length) {
  
  for (int i=0; i<length; i++) {
      for (int j=0; j<length-i+1; j++) {
          if ( arr[j] < arr[j+1] ) {
              swap(arr[j],arr[j+1]);
          }
      }
  }
  
}
```

## 2.选择排序

选择排序的基本思想描述为：每一趟在n-i+1(i=1,2,...,n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。具体来说，假设长度为n的数组arr，要按照从小到大排序，那么先从n个数字中找到最小值min1，如果最小值min1的位置不在数组的最左端(也就是min1不等于arr[0])，则将最小值min1和arr[0]交换，接着在剩下的n-1个数字中找到最小值min2，如果最小值min2不等于arr[1]，则交换这两个数字，依次类推，直到数组arr有序排列。算法的时间复杂度为O(n^2)。

```c++
/* 选择排序 */
void SelectionSort( vector<int> arr, int length) {
    int temp, index;
  
    for (int i=0; i<length; i++) {
        index = i;
        for (int j=i+1; j<length; j++) {
            if ( arr[j] < arr[index] ) {
                index = j;
            }
        }
        if (index != i) {
            swap(arr[index],arr[i]);
        }
     }
}
```
