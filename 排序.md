## 1.冒泡排序

最简单的一种排序算法。假设长度为n的数组arr，要按照从小到大排序。则冒泡排序的具体过程可以描述为：
首先从数组的第一个元素开始到数组最后一个元素为止，对数组中相邻的两个元素进行比较，如果位于数组左端的元素大于数组右端的元素，则交换这两个元素在数组中的位置。这样操作后数组最右端的元素即为该数组中所有元素的最大值。接着对该数组除最右端的n-1个元素进行同样的操作，再接着对剩下的n-2个元素做同样的操作，直到整个数组有序排列。算法的时间复杂度为O(n^2)。

代码：
```c++
/* 冒泡排序 */
void BubbleSort ( vector<int> arr, int length) {
  
  for (int i=0; i<length; i++) {
      for (int j=0; j<length-i+1; j++) {
          if ( arr[j] < arr[j+1] ) {
              swap(arr[j],arr[j+1]);
          }
      }
  }
  
}
```

## 2.选择排序

选择排序的基本思想描述为：每一趟在n-i+1(i=1,2,...,n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。具体来说，假设长度为n的数组arr，要按照从小到大排序，那么先从n个数字中找到最小值min1，如果最小值min1的位置不在数组的最左端(也就是min1不等于arr[0])，则将最小值min1和arr[0]交换，接着在剩下的n-1个数字中找到最小值min2，如果最小值min2不等于arr[1]，则交换这两个数字，依次类推，直到数组arr有序排列。算法的时间复杂度为O(n^2)。

代码：
```c++
/* 选择排序 */
void SelectionSort( vector<int> arr, int length) {
    int temp, index;
  
    for (int i=0; i<length; i++) {
        index = i;
        for (int j=i+1; j<length; j++) {
            if ( arr[j] < arr[index] ) {
                index = j;
            }
        }
        if (index != i) {
            swap(arr[index],arr[i]);
        }
     }
}
```

## 3.插入排序

插入排序的基本思想就是将无序序列插入到有序序列中。例如要将数组arr=[4,2,8,0,5,1]排序，可以将4看做是一个有序序列(图中用蓝色标出)，将[2,8,0,5,1]看做一个无序序列。无序序列中2比4小，于是将2插入到4的左边，此时有序序列变成了[2,4]，无序序列变成了[8,0,5,1]。无序序列中8比4大，于是将8插入到4的右边，有序序列变成了[2,4,8],无序序列变成了[0,5,1]。以此类推，最终数组按照从小到大排序。该算法的时间复杂度为O(n^2)

代码:
```c++
/* 插入排序 */
void InsertSort( vector<int> arr, int length){
    for (int i=1; i<length; i++) {
        int j;
        if ( arr[i] < a[i-1] ) {
            int temp = arr[i];
            for ( j=i-1; j>=0; j-- ) {
                arr[j+1] = arr[j];
            }
            arr[j+1] = temp;
        }
    }
}
```
