![image](https://github.com/Feng3333/Algorithm-and-data-structure/blob/31f89760cb7d75fb28cc6d8618f6080dce5d3b1f/images-folder/sorttime.png)


![image](https://github.com/Feng3333/Algorithm-and-data-structure/blob/31f89760cb7d75fb28cc6d8618f6080dce5d3b1f/images-folder/details.png)

## 1.冒泡排序

最简单的一种排序算法。假设长度为n的数组arr，要按照从小到大排序。则冒泡排序的具体过程可以描述为：
首先从数组的第一个元素开始到数组最后一个元素为止，对数组中相邻的两个元素进行比较，如果位于数组左端的元素大于数组右端的元素，则交换这两个元素在数组中的位置。这样操作后数组最右端的元素即为该数组中所有元素的最大值。接着对该数组除最右端的n-1个元素进行同样的操作，再接着对剩下的n-2个元素做同样的操作，直到整个数组有序排列。算法的时间复杂度为O(n^2)。

代码：
```c++
/* 冒泡排序 */
void BubbleSort ( vector<int> arr, int length) {
  
  for (int i=0; i<length; i++) {
      for (int j=0; j<length-i+1; j++) {
          if ( arr[j] < arr[j+1] ) {
              swap(arr[j],arr[j+1]);
          }
      }
  }
  
}
```

## 2.选择排序

选择排序的基本思想描述为：每一趟在n-i+1(i=1,2,...,n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。具体来说，假设长度为n的数组arr，要按照从小到大排序，那么先从n个数字中找到最小值min1，如果最小值min1的位置不在数组的最左端(也就是min1不等于arr[0])，则将最小值min1和arr[0]交换，接着在剩下的n-1个数字中找到最小值min2，如果最小值min2不等于arr[1]，则交换这两个数字，依次类推，直到数组arr有序排列。算法的时间复杂度为O(n^2)。

代码：
```c++
/* 选择排序 */
void SelectionSort( vector<int> arr, int length) {
    int temp, index;
  
    for (int i=0; i<length; i++) {
        index = i;
        for (int j=i+1; j<length; j++) {
            if ( arr[j] < arr[index] ) {
                index = j;
            }
        }
        if (index != i) {
            swap(arr[index],arr[i]);
        }
     }
}
```

## 3.插入排序

插入排序的基本思想就是将无序序列插入到有序序列中。例如要将数组arr=[4,2,8,0,5,1]排序，可以将4看做是一个有序序列(图中用蓝色标出)，将[2,8,0,5,1]看做一个无序序列。无序序列中2比4小，于是将2插入到4的左边，此时有序序列变成了[2,4]，无序序列变成了[8,0,5,1]。无序序列中8比4大，于是将8插入到4的右边，有序序列变成了[2,4,8],无序序列变成了[0,5,1]。以此类推，最终数组按照从小到大排序。该算法的时间复杂度为O(n^2)

![image](https://github.com/Feng3333/Algorithm-and-data-structure/blob/93e007e127e07ab5ef311a69a610efb788016d06/images-folder/InsertSort.png)


代码:
```c++
/* 插入排序 */
void InsertSort( vector<int> arr, int length){
    for (int i=1; i<length; i++) {
        int j;
        if ( arr[i] < a[i-1] ) {
            int temp = arr[i];
            for ( j=i-1; j>=0; j-- ) {
                arr[j+1] = arr[j];
            }
            arr[j+1] = temp;
        }
    }
}
```


## 4.希尔排序

希尔排序(Shell's Sort)在插入排序算法的基础上进行了改进，算法的时间复杂度与前面几种算法相比有较大的改进。其算法的基本思想是：先将待排记录序列分割成为若干子序列分别进行插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行一次直接插入排序。


![image](https://github.com/Feng3333/Algorithm-and-data-structure/blob/93e007e127e07ab5ef311a69a610efb788016d06/images-folder/ShellSort.png)

代码：
```c++
void ShellSort( vector<int> arr, int length) {
    int increasement = length;
    int i,j,k;
    do {
        //确定分组的增量
        increasement = increasement/3+1;
        for (int i=0; i<increasement; i++) {
            for (int j=i+increasement; j<length; j++) {
                if (arr[j] < arr[j-increasement]) {
                    int temp = arr[j];
                    for ( k = j-increasement; k>=0 && temp < arr[k]; k-=increasement ) {
                        arr[k+increasement] = arr[k];
                    }
                    arr[k+increasement] = temp;
                }
            }
        }
    } while (increasement>1);
}
```
