# 前缀和
## 目录 
 - [1. 一维前缀和](#1-一维前缀和)
 - [2. 二维前缀和](#2-二维前缀和)

## 1. 一维前缀和
### 基本定义
前缀和(Prefix Sum)的定义为：对于一个给定的数列A，其前K项元素的总和就是前缀和;
```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> nums = {1,2,3,4};
    std::vector<int> preSum(4);
    preSum[0] = nums[0];
    for (int i = 1; i < 4; ++i) {
        preSum[i] = preSum[i - 1] + nums[i];
    }

    for (int i = 0; i < 4; ++i) {
        std::cout << "nums[i]: "<< nums[i] << " preSum[i]: " << preSum[i] << std::endl;
    }
    return 0;
}
```
### 简单运用
利用前缀和可以求数组中某个区间的总和:
```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> nums = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    std::vector<int> preSum(10);
    preSum[0] = nums[0];
    for (int i = 1; i < 10; ++i) {
        preSum[i] = preSum[i - 1] + nums[i];
    }
    std::cout << "3 ~ 6中所有数的 sum 为: " << preSum[6] - preSum[2] << std::endl;
    return 0;
}
```

### 例题
#### 题目
给定一个长度为 n 的整数数组nums，其中 n > 1 ，返回输出数组output，其中 output[i] 等于nums中除nums[i]之外其余各元素的乘积.
说明：请不要使用除法，且要求时间复杂度O(n);  

#### 方法介绍
由于不可以利用除法，所以对于每个output[i]，其值等于前面的所有数的乘积sum1 乘上 该值后面的所有数的乘积sum2

基本代码模板: (这里不考虑int * int 变为long long 或者 溢出问题)
```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> prefix(n), suffix(n); //前缀积，后缀积
        prefix[0] = 1; //第一个数的前缀积可以看成1，因为1*num = num;
        suffix[n - 1] = 1;
        for (int i = 1; i < n; ++i) {
            prefix[i] = prefix[i - 1] * nums[i - 1]; //计算该位置(不包含该位置)之前的前缀积
        }
        for (int i = n - 2; i >= 0; --i) {
            suffix[i] = suffix[i + 1] * nums[i + 1];
        }
        
        vector<int> res(n);
        for (int i = 0; i < n; ++i) {
            res[i] = prefix[i] * suffix[i];
        }
        return res;
    }
}
```

空间复杂度O(1)做法，也基本上是运用了的前缀和的思想：
```c++
lass Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        int l = 1, r = 1;
        vector<int> res(n,1);
        for (int i = 0; i < n; ++i) {
            res[i] *= l;
            res[n - 1 - i] *= r;
            l *= nums[i];
            r *= nums[j];
        }
        return res;
    }
}
```

## 2. 二维前缀和

### 基本定义
二维前缀和可以简单理解为：在一个数组矩阵中，所在点位置到其左上角(0, 0)点位置上的所有数字的总和即为二维前缀和；  
举个例子：  
```
1, 2, 3   前缀和    1, 3, 6
1, 2, 4   ----->   2, 6, 13
2, 1, 5            4, 9, 21
```
具体代码实现 :
```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<std::vector<int>> nums{{1, 2, 3}, 
                                       {1, 2, 4},
                                       {2, 1, 5}};
    int m = nums.size(), n = nums[0].size();
    std::vector<std::vector<int>> prefixSum(m + 1, std::vector<int>(n + 1));
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            prefixSum[i][j] = prefixSum[i][j - 1] + prefixSum[i - 1][j] + nums[i - 1][j - 1] - prefixSum[i - 1][j - 1];
        }
    }

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            std::cout << prefixSum[i][j] << " \n"[j == n];
        }
    }
    return 0;
}

```
这里涉及一个如何求二维前缀和的问题，在上述举例中，当我们求点(2, 2)的前缀和时，可以把数组矩阵分为如下四个区域：
![iamge](https://github.com/Feng3333/Algorithm-and-Data-Structure/blob/4cd02c8a132ecd984c1f894524d98a7fbfd04b9b/images-folder/QianZhuiHe2.png)  
在这四个区域中，蓝色和绿色区域相加后再加上红色区域(即该点的value)即可以求出该点的前缀和，但是需要减去蓝色和绿色的公共区域即黄色区域部分，因为这里重复计算了一次黄色区域的前缀和

### 简单运用
利用二维前缀和，可以求出数组矩阵中两点之间所形成的小矩阵中所有数字的sum：  
![iamge](https://github.com/Feng3333/Algorithm-and-Data-Structure/blob/bd2d706628151f1e41ecd10eab585ac6153fba0f/images-folder/QianZhuiHe1.png)  
在上述图中，A点和D点之间的紫色区域所有数字的sum 可以通过 A,B,C,D这四点的前缀和求出,具体公式为：  
```
res = sumD - sumB - sumC + sumA
```
参考代码实现：
```c++
// 左上角点：x,y; 右下角点坐标：i,j
return prefixSum[i][j] - prefixSum[i][y] - prefixSum[x][j] + prefixSum[x][y];
```
