# 回溯算法
## 目录
 - [1.0 回溯算法的基本介绍](#1-回溯算法的基本介绍)
 - [2.0 尝试理解回溯算法](#2-尝试理解回溯算法)
 - [3.0 递归函数的一般写法模板](#3-递归函数的一般写法模板)
 - [4.0 子集型回溯](#4-子集型回溯)


## 1. 回溯算法的基本介绍
### 什么是回溯算法
回溯算法(Back Tracking)，又称试探法，是一种系统地搜索问题解的方法。之所以叫回溯，是因为在搜索解的过程中，如果发现当前路径已不能满足求解条件时，就“回溯”返回，尝试别的路径；

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”（取自百度百科）

回溯算法的简单描述: 把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解

### 回溯与递归
子问题与原问题相似时，从原问题到子问题的过程适合用递归解决；回溯有一个增量构造答案的过程，这个过程通常可以使用递归实现。   

通常回溯可以与递归结合在一起使用，并且回溯部分将作为递归函数的一些条件部分（递归函数的下面一般就为回溯的过程）  
回溯算法实质上是一个纯暴力,不算高效的算法(如果不进行剪枝的话)    


### 回溯算法可以用来处理哪些问题呢 ?
组合问题(强调无序性), 切割问题(比如字符串的切割方式), 子集问题，排列问题(强调元素的有序性)，棋盘问题(解数独, N皇后)

### 基本步骤

1、 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。

2 、确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。 

3 、以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。 

## 2. 尝试理解回溯算法

### 利用树的结构来表示:
树的宽度: 集合的大小(通常使用for循环表示)  
树的深度: 递归的深度(递归的过程)  

### 回溯三问：

- 1. 当前操作：
- 2. 子问题：
- 3. 下一个子问题：


## 3. 递归函数的一般写法模板

```
void backtracking(参数) {
    if (终止条件) {
        收集结果;
        return;
    }
  
    for (遍历集合里的所有元素) {
        处理节点;
        递归函数;
        回溯操作;
    }
    
    return;
}
```

### 4. 子集型回溯
- 本质：对于每个元素都有选和不选两种决定；


